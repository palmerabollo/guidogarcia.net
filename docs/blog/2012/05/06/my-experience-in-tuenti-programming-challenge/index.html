<!DOCTYPE html><html><head>

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">

<meta name="description" content="Call me Sam, a theme for Hugo.">

<meta name="twitter:card" content="summary">
<meta name="twitter:domain" content="https://guidogarcia.net">

<meta name="twitter:image" content="https://guidogarcia.net/tn.png">
<meta name="twitter:title" property="og:title" itemprop="title name" content="Call me Guido">
<meta name="twitter:description" property="og:description" itemprop="description" content="Call me Sam, a theme for Hugo.">
<meta name="og:type" content="website">
<meta name="og:url" content="https://guidogarcia.net">
<meta name="og:image" itemprop="image primaryImageOfPage" content="https://guidogarcia.net/tn.png">

<link rel="shortcut icon" href="https://guidogarcia.net/sam.ico" id="favicon">
<link rel="stylesheet" href="https://guidogarcia.net/css/style.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
    crossorigin="anonymous"></script>







<title>

My experience in the 2nd Tuenti Programming Challenge

</title></head><body>
<div class="wrap">
<div class="section" id="title">My experience in the 2nd Tuenti Programming Challenge</div>

<div class="section" id="content">

<p>This week I have been participating in the 2nd edition of the <a href="https://contest.tuenti.net/">Tuenti Programming Challenge</a>. I felt a little rusty on my return to top-level competition, but despite I started the competition three days late, I was able to reach level 14 (<a href="https://contest.tuenti.net/Stats">stats</a>). Not so bad.</p>

<p>The problems I prefer are those with an obvious brute force solution, but that can take advantage of a particular algorithm or data structure. Most of the problems in this edition belong to this category except, perhaps, the <a href="https://contest.tuenti.net/Questions?id=12">challenge 12</a> which I did not like because I found it too much tricky.</p>

<h3 id="the-crazy-croupier">The crazy croupier</h3>

<p>The challenge I enjoyed the most was the number 13, <a href="https://contest.tuenti.net/Questions?id=13">the crazy croupier</a>. It is kind of a classical problem with minor variations, where you have to determine how many shuffles you need in a deck of N cards in order to come back to the original position if you cut it at the position L.</p>

<p>The <strong>easy -<a href="http://2.bp.blogspot.com/_3IjRgoGWUBo/S-x57diOByI/AAAAAAAAAiA/dTacUrhoTAU/s1600/nukes.jpg">brute force</a>- solution</strong> is to iterate and count until the cards are in their original positions, which can be a time-consuming task when the number of the cards is big (up to 10^6 in this case).</p>

<p>The second approach is to <strong>convert it to a permutations problem</strong>. Once you know  where the card 1..N is located after the first shuffle, you can determine the number of shuffles each individual card needs to come back to its location. The least common multiple of the individual results is the total number of shuffles needed.</p>

<h3 id="show-me-the-code">Show me the code</h3>

<p>Here it is (<a href="https://gist.github.com/gists/2623553/download">download</a>). I do not know how many participants chose Java to solve the problems. What I have seen so far are solutions in Python (<a href="https://github.com/robermorales/Tuenti-Challenge2012-solutions/tree/master/robermorales">here</a>, <a href="https://github.com/TheOm3ga/SolucionesTuenti2012">here</a>) that seem more compact and PHP (<a href="https://github.com/ricardclau/tuenti-contest/tree/master/2012">here</a>). It is a pity that the official ranking does not show the execution times :)</p>

<pre><code>/**
 * Crazy Croupier - 2nd Tuenti Challenge - 12
 * 
 * Example:
 * Number of cards: N = 10
 * Number of cards in the first set: L = 3
 * Cards: 10 1 4 2 8 5 6 7 3 9
 * 
 * First set: 10 1 4
 * Second set: 2 8 5 6 7 3 9
 * 
 * Shuffled set: 4 9 1 3 10 7 6 5 8 2
 */
public static void main(String[] args) {
  Scanner scanner = new Scanner(System.in);

  // read number of cases
  int cases = Integer.parseInt(scanner.nextLine());

  for (int i=1; i&lt;=cases; i++) {
    // read N L, for example 10 6
    String line = scanner.nextLine();
    String[] arguments = line.split(&quot; &quot;);

    // N = cards in the deck
    int N = Integer.parseInt(arguments[0]);

    // L cards in the first bunch (where to cut the deck)
    int L = Integer.parseInt(arguments[1]);

    long result = processCase(N, L);
    System.out.printf(&quot;Case #%d: %d\n&quot;, i, result);
  }
}

/**
 * Returns the number of shuffles required to return the deck
 * to its original order.
 * The algorithm will calculate the number of iterations that
 * each individual card need to come back to its position. The
 * solution will be the least common multiple (lcm) of the
 * individual results.
 */
private static long processCase(int n, int cut) {
  int[] deck = new int[n]; // first deck shuffling result

  shuffleDeck(n, cut, deck);

  // cache source -&gt; target positions for O(1) access
  final Map&lt;Integer, Integer&gt; permutations = new HashMap&lt;Integer, Integer&gt;();
  for (int i=0; i&lt;deck.length; i++) {
    permutations.put(deck[i], i+1);
  }

  // cache to avoid multiple lcd calculations of the same num, O(1) access
  Set&lt;Long&gt; calculatedLcm = new HashSet&lt;Long&gt;();
  long lcm = 0;
  for (int i=0; i&lt;deck.length; i++) {
    long numberPermutations = 1; // we already did the first shuffling
    int currentPosition = i+1;

    // still no at the original position
    while (currentPosition != deck[i]) {
      numberPermutations++;
      currentPosition = permutations.get(currentPosition);
    }

    if (calculatedLcm.contains(numberPermutations) == false) {
      lcm = lcm(lcm, numberPermutations);
      calculatedLcm.add(numberPermutations);
    }
  }

  return lcm;
}

/**
 * Shuffles the deck one time according to the algorithm.
 */
private static void shuffleDeck(int n, int cut, int[] deck) {
  int min = Math.min(cut, n-cut); // number of cards shuffled

  // shuffle two bunch of cards
  for (int i=0; i&lt;min; i++) {
    deck[2 * i] = cut - i;   // 1st bunch
    deck[2 * i + 1] = n - i; // 2nd bunch
  }

  // put the rest of the cards in proper order, at the end
  for (int i=0; i&lt;n - 2 * min; i++) {
    if (cut &gt;= n / 2) { // first bunch is bigger
      deck[n - 1 - i] = i + 1;
    } else { // second bunch is bigger or equal
      deck[2 * min + i] = n - min - i;
    }
  }
}

/**
 * Least common multiple. Probably a more efficient approach can be
 * found but it is good enough.
 */
private static long lcm(long a, long b) {
  if (a == 0 || b == 0) {
    return Math.max(a, b);
  }
  return a * b / gcd(a, b);
}

/**
 * Greatest common divisor, see also {@link BigInteger#gcd(BigInteger)}
 */
private static long gcd(long a, long b) {
  long mod = a % b;
  return mod == 0 ? b : gcd(b, mod);
}
</code></pre>

<p>What do you think about it?</p>

<h3 id="talent-is-out-there">Talent is out there</h3>

<p>I like these competitions (Google Code Jam, ACM ICPC, etc) a lot and I think it is a great (and cheap) opportunity for technological companies to attract and recruit talent. There are a lot of great coders hidden out there.</p>
</div>


<div class="section bottom-menu"><hr/><p>


<a href="/posts">Hello. Call me Guido</a>


&#183; <a href="https://twitter.com/palmerabollo">Twitter</a>
&#183; <a href="http://bot.guidogarcia.net/">My bot (alpha)</a>

&#183; <a href="https://guidogarcia.net"></a></p></div>


<div class="section footer"></div>
</div>
</body></html>